# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an **AI React Viewer** project - a React + TypeScript + Vite application for viewing and managing React
components and HTML files generated by AI tools (Claude and Gemini).

**Core Purpose**:

- View AI-generated React components and HTML files in a web interface
- Search and filter files by metadata (AI source, tags, dates)
- Export content to PDF for documentation
- Provide secure rendering with proper isolation

**Technology Stack**: React + Vite + TypeScript + Tailwind CSS + React Router

## Important Development Guidelines

### PR Implementation Rules

When implementing PRs from the requirements document (@ai-react-viewer-requirements.md):

1. **Focus on the Given Task Only**
   - Complete ONLY the specific tasks mentioned in the PR description
   - Do NOT implement features from other PRs or add extra functionality
   - Stay within the defined scope of each PR

2. **Request Confirmation for Additional Work**
   - If you identify missing dependencies or prerequisites, ASK before implementing
   - If a task seems to require additional features, CONFIRM before proceeding
   - Never assume - always clarify when in doubt

3. **Examples of What NOT to Do**
   - PR2 asks for TypeScript interfaces and sample metadata.json → Do NOT create sample React/HTML files
   - PR5 asks for Claude file loader → Do NOT implement the renderer component
   - PR7 asks for FileCard component → Do NOT create the entire Home page

4. **Proper Workflow**
   - Read the PR description carefully
   - Implement ONLY what is explicitly requested
   - Test that your implementation meets the stated requirements
   - If additional work seems necessary, ask: "This PR requires X. Should I also implement Y?"

## Essential Commands

```bash
# Development
npm run dev          # Start development server (Vite)

# Build
npm run build        # Type-check with TypeScript then build for production

# Code Quality
npm run lint         # Run ESLint to check for code issues

# Preview
npm run preview      # Preview production build locally

# Metadata Management
npm run generate-metadata  # Generate metadata.json from file system scan
```

## Architecture

```
project/
├── src/
│   ├── main.tsx              # Application entry point
│   ├── App.tsx               # Main React component with routing
│   ├── pages/
│   │   ├── Home.tsx          # File list page with search/filter
│   │   └── Viewer.tsx        # File viewer page
│   ├── components/
│   │   ├── FileList.tsx      # File listing component
│   │   ├── FileCard.tsx      # Individual file card
│   │   ├── SearchPanel.tsx   # Search and filter UI
│   │   └── renderers/
│   │       ├── ReactRenderer.tsx  # Claude React component renderer
│   │       └── HTMLRenderer.tsx   # Gemini HTML renderer (iframe)
│   ├── utils/
│   │   ├── fileLoader.ts     # Dynamic file loading utilities
│   │   └── metadataManager.ts # Metadata operations
│   └── types/
│       └── metadata.ts       # TypeScript interfaces
├── references/               # AI-generated files storage
│   ├── claude/              # Claude React components (.tsx, .jsx)
│   ├── gemini/              # Gemini HTML files (.html)
│   └── metadata.json        # File metadata database
└── scripts/
    └── generate-metadata.js  # Metadata generation script
```

**Key Components**:

- **Home Page**: 2-column layout (Claude | Gemini) with search/filter
- **Viewer Page**: Full-screen file rendering with proper isolation
- **File Loaders**: Dynamic import using `import.meta.glob()`
- **Metadata System**: JSON-based file management with search indexing

## Development Notes

- The project uses React 19.1.0 with the new React Compiler
- TypeScript is configured with strict mode enabled
- ESLint includes plugins for React hooks and React refresh
- Vite handles hot module replacement (HMR) for fast development

## Key Features & Implementation

### File Loading System

- **Claude Files**: Dynamic import with `import.meta.glob('/references/claude/*.{tsx,jsx}')`
- **Gemini Files**: Raw text loading with `import.meta.glob('/references/gemini/*.html', { as: 'raw' })`
- **Error Handling**: Graceful fallbacks for missing or corrupted files

### Security & Isolation

- **HTML Rendering**: iframe with sandbox attributes for Gemini HTML files
- **XSS Prevention**: Proper content isolation and sanitization
- **Component Isolation**: Error boundaries for React component rendering

### Metadata Schema

```typescript
interface FileMetadata {
    id: string                    // Unique identifier
    filename: string              // File name
    path: string                  // Relative path
    ai: 'claude' | 'gemini'      // AI source
    type: 'react' | 'html'       // File type
    title: string                 // Display title
    description?: string          // File description
    tags: string[]               // Search tags
    createdAt: string            // ISO 8601 date
    updatedAt: string            // ISO 8601 date
    dependencies?: string[]       // Used libraries
    size: number                 // File size in bytes
}
```

### Routing Structure

- **Home**: `/` - File listing with search/filter
- **Viewer**: `/view/:ai/:filename` - File rendering page

### Performance Optimizations

- **Lazy Loading**: React.lazy() for code splitting
- **Metadata Caching**: In-memory caching for fast search
- **On-Demand Loading**: Files loaded only when needed

## TypeScript Configuration

The project uses a multi-file TypeScript configuration:

- `tsconfig.json`: Root configuration that references other configs
- `tsconfig.app.json`: Application-specific TypeScript settings
- `tsconfig.node.json`: Node.js environment settings for build tools

## PDF Export & Printing

- **Print CSS**: Optimized styles for PDF export
- **Page Layout**: Proper page breaks and layout control
- **Browser Integration**: Uses browser's native print functionality

## Code Style Guidelines

### Comments
- **Language**: Write all comments in English
- **Purpose**: Comments should explain the "why" rather than the "what"
- **Examples**:
  ```typescript
  // Load metadata from JSON file and cache in memory
  const metadata = await loadMetadata();
  
  // Prevent XSS attacks by sanitizing HTML content
  const safeHTML = sanitizeHTML(rawHTML);
  ```

### Package Management
- **Import Strategy**: Write implementation code first, then add imports afterward
- **Reason**: IDE auto-formatting may remove unused imports during development
- **Workflow**:
  1. Write the component/function code that uses the new package
  2. Add the import statement after the code is complete
  3. This prevents IDEs from automatically removing "unused" imports during development
