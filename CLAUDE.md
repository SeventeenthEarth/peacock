# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an **AI React Viewer** project - a React + TypeScript + Vite application for viewing and managing React
components and HTML files generated by AI tools (Claude and Gemini).

**Core Purpose**:

- View AI-generated React components and HTML files in a web interface
- Search and filter files by metadata (AI source, tags, dates)
- Export content to PDF for documentation
- Provide secure rendering with proper isolation

**Technology Stack**: React + Vite + TypeScript + Tailwind CSS + React Router

## Important Development Guidelines

### PR Implementation Rules

When implementing PRs from the requirements document (@ai-react-viewer-requirements.md):

1. **Focus on the Given Task Only**
   - Complete ONLY the specific tasks mentioned in the PR description
   - Do NOT implement features from other PRs or add extra functionality
   - Stay within the defined scope of each PR

2. **Request Confirmation for Additional Work**
   - If you identify missing dependencies or prerequisites, ASK before implementing
   - If a task seems to require additional features, CONFIRM before proceeding
   - Never assume - always clarify when in doubt

3. **Examples of What NOT to Do**
   - PR2 asks for TypeScript interfaces and sample metadata.json → Do NOT create sample React/HTML files
   - PR5 asks for Claude file loader → Do NOT implement the renderer component
   - PR7 asks for FileCard component → Do NOT create the entire Home page

4. **Proper Workflow**
   - Read the PR description carefully
   - Implement ONLY what is explicitly requested
   - Test that your implementation meets the stated requirements
   - If additional work seems necessary, ask: "This PR requires X. Should I also implement Y?"

## Essential Commands

```bash
# Development
npm run dev          # Start development server (Vite)

# Build
npm run build        # Type-check with TypeScript then build for production

# Code Quality
npm run lint         # Run ESLint to check for code issues

# Preview
npm run preview      # Preview production build locally

# Metadata Management
npm run generate-metadata  # Generate metadata.json from file system scan
```

## Architecture

```
project/
├── src/
│   ├── main.tsx              # Application entry point
│   ├── App.tsx               # Main React component with routing
│   ├── pages/
│   │   ├── Home.tsx          # File list page with search/filter
│   │   └── Viewer.tsx        # File viewer page
│   ├── components/
│   │   ├── FileList.tsx      # File listing component
│   │   ├── FileCard.tsx      # Individual file card
│   │   ├── SearchPanel.tsx   # Search and filter UI
│   │   └── renderers/
│   │       ├── ReactRenderer.tsx  # Claude React component renderer
│   │       └── HTMLRenderer.tsx   # Gemini HTML renderer (iframe)
│   ├── utils/
│   │   ├── fileLoader.ts     # Dynamic file loading utilities
│   │   └── metadataManager.ts # Metadata operations
│   └── types/
│       └── metadata.ts       # TypeScript interfaces
├── references/               # AI-generated files storage
│   ├── claude/              # Claude React components (.tsx, .jsx)
│   ├── gemini/              # Gemini HTML files (.html)
│   └── metadata.json        # File metadata database
└── scripts/
    └── generate-metadata.js  # Metadata generation script
```

**Key Components**:

- **Home Page**: 2-column layout (Claude | Gemini) with search/filter
- **Viewer Page**: Full-screen file rendering with proper isolation
- **File Loaders**: Dynamic import using `import.meta.glob()`
- **Metadata System**: JSON-based file management with search indexing

## Development Notes

- The project uses React 19.1.0 with the new React Compiler
- TypeScript is configured with strict mode enabled
- ESLint includes plugins for React hooks and React refresh
- Vite handles hot module replacement (HMR) for fast development

## Key Features & Implementation

### File Loading System

- **Claude Files**: Dynamic import with `import.meta.glob('/references/claude/*.{tsx,jsx}')`
- **Gemini Files**: Raw text loading with `import.meta.glob('/references/gemini/*.html', { as: 'raw' })`
- **Error Handling**: Graceful fallbacks for missing or corrupted files

### Security & Isolation

- **HTML Rendering**: iframe with sandbox attributes for Gemini HTML files
- **XSS Prevention**: Proper content isolation and sanitization
- **Component Isolation**: Error boundaries for React component rendering

### Metadata Schema

```typescript
interface FileMetadata {
    id: string                    // Unique identifier
    filename: string              // File name
    path: string                  // Relative path
    ai: 'claude' | 'gemini'      // AI source
    type: 'react' | 'html'       // File type
    title: string                 // Display title
    description?: string          // File description
    tags: string[]               // Search tags
    createdAt: string            // ISO 8601 date
    updatedAt: string            // ISO 8601 date
    dependencies?: string[]       // Used libraries
    size: number                 // File size in bytes
}
```

### Routing Structure

- **Home**: `/` - File listing with search/filter
- **Viewer**: `/view/:ai/:filename` - File rendering page

### Performance Optimizations

- **Lazy Loading**: React.lazy() for code splitting
- **Metadata Caching**: In-memory caching for fast search
- **On-Demand Loading**: Files loaded only when needed

## TypeScript Configuration

The project uses a multi-file TypeScript configuration:

- `tsconfig.json`: Root configuration that references other configs
- `tsconfig.app.json`: Application-specific TypeScript settings
- `tsconfig.node.json`: Node.js environment settings for build tools

## PDF Export & Printing

- **Print CSS**: Optimized styles for PDF export
- **Page Layout**: Proper page breaks and layout control
- **Browser Integration**: Uses browser's native print functionality

## Code Style Guidelines

### Comments
- **Language**: Write all comments in English
- **Purpose**: Comments should explain the "why" rather than the "what"
- **Examples**:
  ```typescript
  // Load metadata from JSON file and cache in memory
  const metadata = await loadMetadata();
  
  // Prevent XSS attacks by sanitizing HTML content
  const safeHTML = sanitizeHTML(rawHTML);
  ```

### Package Management
- **Import Strategy**: Write implementation code first, then add imports afterward
- **Reason**: IDE auto-formatting may remove unused imports during development
- **Workflow**:
  1. Write the component/function code that uses the new package
  2. Add the import statement after the code is complete
  3. This prevents IDEs from automatically removing "unused" imports during development

## Claude Code Workflows

### Adding New AI-Generated Files

1. **For Claude React Components (.tsx/.jsx)**:
   ```bash
   # Add file to references/claude/
   # Then regenerate metadata
   npm run generate-metadata
   
   # Verify in browser
   npm run dev
   ```

2. **For Gemini HTML Files (.html)**:
   ```bash
   # Add file to references/gemini/
   # Then regenerate metadata
   npm run generate-metadata
   
   # Verify in browser
   npm run dev
   ```

### Troubleshooting File Issues

1. **File not appearing in list**:
   ```bash
   # Check file location
   ls references/claude/
   ls references/gemini/
   
   # Regenerate metadata
   npm run generate-metadata
   
   # Check metadata content
   cat references/metadata.json
   ```

2. **Component rendering errors**:
   ```bash
   # Check browser console
   # Verify component syntax
   npm run lint
   
   # Test build
   npm run build
   ```

### PDF Export Workflow

1. **Optimize for printing**:
   - Navigate to viewer page (`/view/:ai/:filename`)
   - Use Ctrl+P (Windows/Linux) or Cmd+P (Mac)
   - Set paper size to A4
   - Enable "Background graphics"

2. **Print CSS debugging**:
   ```bash
   # Test print styles in browser dev tools
   # Use print media emulation
   # Check @media print rules in CSS
   ```

### Project Maintenance

#### Code Quality Checks

```bash
# Run all quality checks
npm run lint          # ESLint
npm run build         # TypeScript + Build

# Fix linting issues
npx eslint . --fix
```

#### Performance Monitoring

- **Metadata Loading**: Should be < 1 second
- **File Rendering**: Should be near-instant with caching
- **Search Response**: Should be < 100ms
- **Build Size**: Monitor bundle size with `npm run build`

#### Adding New Features

1. **Follow PR-based approach**: Implement one feature at a time
2. **Update metadata schema**: If adding new file properties
3. **Update search indexes**: If adding searchable content
4. **Test across file types**: Both Claude and Gemini files
5. **Verify print output**: Ensure PDF export still works

### Emergency Recovery

#### Corrupted Metadata

```bash
# Backup current metadata
cp references/metadata.json references/metadata.json.backup

# Regenerate from scratch
npm run generate-metadata

# Compare and verify
diff references/metadata.json.backup references/metadata.json
```

#### Missing Dependencies

```bash
# Reinstall all dependencies
rm -rf node_modules package-lock.json
npm install

# Clear browser cache and restart dev server
npm run dev
```

#### Build Failures

```bash
# Check TypeScript errors
npx tsc --noEmit

# Check for missing imports
npm run lint

# Clean build
rm -rf dist/
npm run build
```

## User Workflow Examples

### Daily Usage Pattern

1. **Generate new AI content** (Claude/Gemini)
2. **Save files** to appropriate directories
3. **Run metadata generation**: `npm run generate-metadata`
4. **Refresh app** and view new content
5. **Export to PDF** as needed

### Team Collaboration

1. **Share references folder** with team members
2. **Include metadata.json** in version control
3. **Document file naming conventions**
4. **Maintain consistent folder structure**

# important-instruction-reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.
